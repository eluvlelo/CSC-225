# Time and Calendar Exercise
# Create a system of classes to represent time, dates, and appointments in a calendar application.

# Multiple inheritance
# Method overriding
# Date and time manipulation
# Complex validation logic
# Designing a coherent class hierarchy
# Submit your solution as well-documented Python code with appropriate comments and test cases.

import math

# Part 1: Time Class

class Time:
    '''Represents the time of day.
    
    Attributes: hours, minutes, seconds
    '''
    # Create a Time class with attributes for hours, minutes, and seconds
    def __init__(self, hours, minutes, seconds):
        self.hours = hours
        self.minutes = minutes
        self.seconds = seconds

    # Formats the time as "HH:MM:SS"
    def __str__(self):
        s=  f"{self.hours:02d}:{self.minutes:02d}:{self.seconds:02d}"
        return s
    
    # Checks if the time is valid (hours 0-23, minutes 0-59, seconds 0-59)
    def is_valid(self):
        if (self.hours >= 0) and (self.minutes >= 0) and (self.seconds >= 0) and (self.hours <= 23) and (self.minutes <= 59) and (self.seconds <= 59):
            return True
        else:
            return False
    
    # Compare times chronologically
    def __lt__(self, other):
        assert self.is_valid(), 'self is not a valid Time'
        assert other.is_valid(), 'other is not a valid Time'
        if self.hours > other.hours:
            return True
        if self.hours == other.hours and self.minutes > other.minutes:
            return True
        if self.hours == other.hours and self.minutes == other.minutes and self.seconds > other.seconds:
            return True
        return False
        
    # Adds times, ensuring proper carry/borrow operations
    def __add__(self, other): 
        minute = math.trunc((self.seconds + other.seconds)/60)
        hour = math.trunc((self.minutes + other.minutes + minute)/60)
        self.seconds = (self.seconds + other.seconds) % 60
        self.minutes = (self.minutes + other.minutes + minute) % 60
        self.hours = (self.hours + other.hours + hour) % 24
        return self

    # Subtracts times, ensuring proper carry/borrow operations
    def __subtract__(self, other):
        assert self.__lt__(other)   
        self.seconds = self.seconds - other.seconds
        if self.seconds < 0:
            minutes = 1
            self.seconds = 0
        else: 
            minutes = 0
        self.minutes = self.minutes - other.minutes - minutes
        if self.minutes < 0:
            hours = 1
            self.minutes = 0
        else: 
            hours = 0
        self.hours = self.hours - other.hours - hours
        return self
    
    def __subtract__(self, other):
        assert self.__lt__(other)   
        if self.seconds < other.seconds:
            self.minutes -= 1
            self.seconds += 60
            self.seconds = self.seconds - other.seconds
        else:
            self.seconds = self.seconds - other.seconds
        if (self.minutes - other.minutes) < 0:
            self.hours -= 1
            self.minutes += 60
            self.minutes = self.minutes - other.minutes
        else:
            self.minutes = self.minutes - other.minutes
        self.hours = self.hours - other.hours
        return self
        
# Part 2: Date Class

class Date: 
    '''Represents calendar date.
    
    Attributes: year, month, day
    '''
    # Initialize with year, month, and day attributes
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day

    # Formats the date as "YYYY-MM-DD"
    def __str__(self):
        return f"{self.year:04d}-{self.month:02d}-{self.day:02d}"

    # Checks if the date is valid (considering month lengths and leap years)
    def is_valid(self):
        # create list of days in each month
        days_in_month = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        # change days in February depending on leap year
        if self.year % 4 == 0 and (self.year % 100 != 0 or self.year % 400 == 0):
            days_in_month[2] = 29
        # checks if month is between 1 and 12 and if days are between 1 and corresponding days in list based on index of month
        if (1 <= self.month <= 12 and 1 <= self.day <= days_in_month[self.month]):
            return True
        return False
    
    # Compare dates chronologically
    def __lt__(self, other):
        assert self.is_valid(), 'self is not a valid Date'
        assert other.is_valid(), 'other is not a valid Date'
        if self.year > other.year:
            return True
        if self.year == other.year and self.month > other.month:
            return True
        if self.year == other.year and self.month == other.month and self.day > other.day:
            return True
        return False 
        
    # Calculate the day of the week for any date
    # def day_of_week(self):
    #     assert self.is_valid()
    #     days = [Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday]
    #     if self.year % 4 == 0 and (self.year % 100 != 0 or self.year % 400 == 0):
    #     else:
    #         days = days[]

# Part 3: Appointment Class
# Create an Appointment class that inherits from both Date and Time:

# Create a new class DateTime that combines date and time information
class DateTime:
    '''Represents date and time.

    Attributes: date, time
    '''
    def __init__(self, year, month, day, hours, minutes, seconds):
        self.date = Date(year, month, day)
        self.time = Time(hours, minutes, seconds)

    def __str__(self):
        return f"{self.date} {self.time}"

# Create an Appointment class that inherits from DateTime
class Appointment:
    '''Represents appointment date and time.
    
    Attributes: datetime, title, duration(in minutes), location, description
    '''
    def __init__(self, year, month, day, hours, minutes, seconds, title, duration, location, description):
        
        self.datetime = DateTime(year, month, day, hours, minutes, seconds)
        self.title = title
        self.duration = duration
        self.location = location
        self.description = description

    # Format the appointment information nicely
    def __str__(self):
        return f"Your {self.title} appointment for a {self.description} at {self.location} is at {self.datetime} and lasts {self.duration} minutes."

    # Checks if two appointments overlap
    def conflicts_with(self, other):
        if self.datetime == other.datetime:
            return False
        # add duration(in minutes) to appointment time and check if result is equal to other appointment
        else: 
            hours = abs(self.minutes + self.duration)
            self.minutes = (self.minutes + self.duration) % 60
            self.hours = (self.hours + hours) % 24
            self.datetime = DateTime(self.year, self.month, self.day, self.hours, self.minutes, self.seconds)
            if self.datetime > other.datetime:
                return True


time = Time(24,60,60)
print(f"Is {time} valid:")
print(time.is_valid())
print()

time = Time(23,59,59)
other = Time(23,59,58)
print(f"Is {time} after {other}?")
print(time.__lt__(other))
print()

time = Time(1,30,30)
other = Time(0,29,30)
print(f"{time} + {other} =")
print(time.__add__(other))
print()

time = Time(10,0,0)
other = Time(0,0,1)
print(f"{time} - {other} =")
print(time.__subtract__(other))
print()

date = Date(2025,2,29)
print(f"Is {date} valid?")
print(date.is_valid())
print()

date = Date(2024,2,29)
print(f"Is {date} valid?")
print(date.is_valid())
print()

date = Date(2025,3,7)
other = Date(2025,3,6)
print(f"Is {date} after {other}?")
print(date.__lt__(other))
print()

appointment = Appointment(2025, 3, 7, 2, 0, 0, 'Optometrist', 60, 'LensCrafters, Cambridge', 'comprehensive eye exam')
other = Appointment(2025, 3, 7, 2, 0, 0, 'Doctors', 60, 'EBNHC, Winthrop', 'yearly checkup')
print(appointment)
print()
print(other)
print()
print('Do these appointments overlap?')
print(appointment.conflicts_with(other))
