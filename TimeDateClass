# Time and Calendar Exercise
# Create a system of classes to represent time, dates, and appointments in a calendar application.

# Multiple inheritance
# Method overriding
# Date and time manipulation
# Complex validation logic
# Designing a coherent class hierarchy
# Submit your solution as well-documented Python code with appropriate comments and test cases.

import math

# Part 1: Time Class

class Time:
    '''Represents the time of day.
    
    Attributes: hours, minutes, seconds
    '''
    # Create a Time class with attributes for hours, minutes, and seconds
    def __init__(self, hours=0, minutes=0, seconds=0):
        self.hours = hours
        self.minutes = minutes
        self.seconds = seconds

    # Formats the time as "HH:MM:SS"
    def __str__(self):
        s = f"{self.hours:02d}:{self.minutes:02d}:{self.seconds:02d}"
        return s
    
    # Checks if the time is valid (hours 0-23, minutes 0-59, seconds 0-59)
    def is_valid(self):
        if (self.hours >= 0) and (self.minutes >= 0) and (self.seconds >= 0) and (self.hours <= 23) and (self.minutes <= 59) and (self.seconds <= 59):
            return True
        else:
            return False
    
    # Compare times chronologically
    def __lt__(self, other):
        assert self.is_valid(), 'self is not a valid Time'
        assert other.is_valid(), 'other is not a valid Time'
        if self.hours > other.hours:
            return True
        if self.hours == other.hours and self.minutes > other.minutes:
            return True
        if self.hours == other.hours and self.minutes == other.minutes and self.seconds > other.seconds:
            return True
        return False
        
    # Adds times, ensuring proper carry/borrow operations
    def __add__(self, other): 
        minute = math.trunc((self.seconds + other.seconds)/60)
        hour = math.trunc((self.minutes + other.minutes + minute)/60)
        self.seconds = (self.seconds + other.seconds) % 60
        self.minutes = (self.minutes + other.minutes + minute) % 60
        self.hours = (self.hours + other.hours + hour) % 24
        return self

    # Subtracts times, ensuring proper carry/borrow operations
    def __subtract__(self, other):
        assert self.__lt__(other)   
        if self.seconds < other.seconds:
            self.minutes -= 1
            self.seconds += 60
            self.seconds = self.seconds - other.seconds
        else:
            self.seconds = self.seconds - other.seconds
        if (self.minutes - other.minutes) < 0:
            self.hours -= 1
            self.minutes += 60
            self.minutes = self.minutes - other.minutes
        else:
            self.minutes = self.minutes - other.minutes
        self.hours = self.hours - other.hours
        return self
        
# Part 2: Date Class

class Date: 
    '''Represents calendar date.
    
    Attributes: year, month, day
    '''
    # Initialize with year, month, and day attributes
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day

    # Formats the date as "YYYY-MM-DD"
    def __str__(self):
        return f"{self.year:04d}-{self.month:02d}-{self.day:02d}"

    # Checks if the date is valid (considering month lengths and leap years)
    def is_valid(self):
        # create list of days in each month
        days_in_month = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        # change days in February depending on leap year
        if self.year % 4 == 0 and (self.year % 100 != 0 or self.year % 400 == 0):
            days_in_month[2] = 29
        # checks if month is between 1 and 12 and if days are between 1 and corresponding days in list based on index of month
        if (1 <= self.month <= 12 and 1 <= self.day <= days_in_month[self.month]):
            return True
        return False
    
    # Compare dates chronologically
    def __after__(self, other):
        assert self.is_valid(), 'self is not a valid Date'
        assert other.is_valid(), 'other is not a valid Date'
        if self.year > other.year:
            return True
        if self.year == other.year and self.month > other.month:
            return True
        if self.year == other.year and self.month == other.month and self.day > other.day:
            return True
        return False 
        
    # Calculate the day of the week for any date
    # def day_of_week(self):
    #     assert self.is_valid()
    #     days = [Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday]
    #     if self.year % 4 == 0 and (self.year % 100 != 0 or self.year % 400 == 0):
    #     else:
    #         days = days[]

# Part 3: Appointment Class
# Create an Appointment class that inherits from both Date and Time:

# Create a new class DateTime that combines date and time information
class DateTime:
    '''Represents date and time.

    Attributes: date, time
    '''
    def __init__(self, year, month, day, hours, minutes, seconds):
        self.date = Date(year, month, day)
        self.time = Time(hours, minutes, seconds)

    def __str__(self):
        return f"{self.date} {self.time}"

# Create an Appointment class that inherits from DateTime
class Appointment:
    '''Represents appointment date and time.
    
    Attributes: datetime, title, duration(in minutes), location, description
    '''
    def __init__(self, year, month, day, hours, minutes, seconds, title, duration, location, description):
        self.datetime = DateTime(year, month, day, hours, minutes, seconds)
        self.date = Date(year, month, day)
        self.time = Time(hours, minutes, seconds)
        self.year = year
        self.month = month
        self.day = day
        self.hours = hours
        self.title = title
        self.duration = duration
        self.location = location
        self.description = description

    # Format the appointment information nicely
    def __str__(self):
        return f"Your {self.title} appointment for a {self.description} at {self.location} is at {self.datetime} and lasts {self.duration} minutes."

    # Checks if two appointments overlap
    def conflicts_with(self, other):
        if self.date.__after__(other.date) or other.date.__after__(self.date):
            return False
        elif self.date.__after__(other.date) == other.date.__after__(self.date) == False:
            if self.time.__lt__(other.time) == other.time.__lt__(self.time) == False:
                return True
            elif other.time.__lt__(self.time):
                minutes = self.duration % 60
                hours = math.trunc(self.duration/60)
                duration = Time(hours, minutes, 0)
                self.time = self.time.__add__(duration)
                if self.time.__lt__(other.time):
                    return True
                elif self.time.__lt__(other.time) == other.time.__lt__(self.time) == False:
                    return True
                else:
                    return False
            elif self.time.__lt__(other.time):
                minutes = self.duration % 60
                hours = math.trunc(self.duration/60)
                duration = Time(hours, minutes, 0)
                other.time = other.time.__add__(duration)
                if other.time.__lt__(self.time):
                    return True
                elif self.time.__lt__(other.time) == other.time.__lt__(self.time) == False:
                    return True
                else: 
                    return False
                
# Part 4: Calendar Class
# Create a Calendar class to manage a collection of appointments:

class Calendar:
    '''Collection of appointments.

    Attributes:
    '''
    # Initialize with a name and an empty list of appointments
    def __init__(self, name):
        self.name = name
        self.appointments = []
    
    # Add methods to add appointments
    def add_appt(self, appt):
        self.appointments.append(appt)

    # Add methods to remove appointments
    def remove_appt(self, appt):
        if appt in self.appointments:
            self.appointments.remove(appt)

    # Find all appointments on a given date
    def find_appt(self, date):
        return [appt for appt in self.appointments if (appt.year, appt.month, appt.day) == (date.year, date.month, date.day)]

    # Find conflicts among all appointments
    def find_conflicts(self):
        conflicts = []
        for i in range(len(self.appointments)):
            for j in range(i + 1, len(self.appointments)):
                 if self.appointments[i].conflicts_with(self.appointments[j]):
                    conflicts.append((self.appointments[i], self.appointments[j]))
        return conflicts

    # Print a formatted daily or weekly view of appointments
    def daily_view(self, year, month, day):
        print(f"Weekly view for {year}[{month:02}-{day:02}]")
        appts = self.find_appt(Date(year, month, day))
        for appt in sorted(appt, key=):
            print(appt)

# Part 5: Specialized Calendar Types
# Create at least two specialized calendar types that inherit from Calendar:

# WorkCalendar - with methods specific to work appointments
class WorkCalendar(Calendar):
    def add_appt(self, appt):
        if 9 <= appt.hours < 17:
            super().add_appt(appt)
        else:
            print("Work appointments must be between 9 am and 5 pm")

# SchoolCalendar - with methods specific to academic appointments
class SchoolCalendar(Calendar):
    def add_appt(self, appt):
        if appt.duration <= 180:
            super().add_appt(appt)
        else:
            print("School appointments cannot exceed 3 hours.")

time = Time(24,60,60)
print(f"Is {time} valid:")
print(time.is_valid())
print()

time = Time(23,59,59)
other = Time(23,59,58)
print(f"Is {time} after {other}?")
print(time.__lt__(other))
print()

time = Time(1,30,30)
other = Time(0,29,30)
print(f"{time} + {other} =")
print(time.__add__(other))
print()

time = Time(10,0,0)
other = Time(0,0,1)
print(f"{time} - {other} =")
print(time.__subtract__(other))
print()

date = Date(2025,2,29)
print(f"Is {date} valid?")
print(date.is_valid())
print()

date = Date(2024,2,29)
print(f"Is {date} valid?")
print(date.is_valid())
print()

date = Date(2025,3,7)
other = Date(2025,3,6)
print(f"Is {date} after {other}?")
print(date.__after__(other))
print()

appointment = Appointment(2025, 3, 5, 4, 45, 0, 'Optometrist', 60, 'LensCrafters, Cambridge', 'comprehensive eye exam')
other = Appointment(2025, 3, 5, 4, 45, 0, 'Doctors', 60, 'EBNHC, Winthrop', 'yearly checkup')
print(appointment)
print()
print(other)
print()
print('Do these appointments overlap?')
print(appointment.conflicts_with(other))
print()

appointment = Appointment(2025, 3, 5, 4, 45, 0, 'Optometrist', 60, 'LensCrafters, Cambridge', 'comprehensive eye exam')
other = Appointment(2025, 3, 5, 5, 45, 0, 'Doctors', 60, 'EBNHC, Winthrop', 'yearly checkup')
print(appointment)
print()
print(other)
print()
print('Do these appointments overlap?')
print(appointment.conflicts_with(other))
print()

appt1 = Appointment(2025, 3, 7, 14, 0, 0, "Safety Briefing", 30, "Conference Room", "Review Safety Rules")
appt2 = Appointment(2025, 3, 7, 14, 30, 0, "Training", 60, "Computer Room", "Work Training")
print(appt1)
print(appt2)
print()
print('Do these appointments overlap?')
print(appt1.conflicts_with(appt2))

work_cal = WorkCalendar("Work")
work_cal.add_appt(appt1)
work_cal.add_appt(appt2)
work_cal.daily_view(2025, 3, 7)
